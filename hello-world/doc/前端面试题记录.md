<!-- 1、基本的数据类型 -->
    5个简单数据类型（基本数据类型）+ 1个复杂数据类型
    undefiend, number, string, null, boolean + object
    ES6 新增Symbol

<!-- 2.v-show和v-if有什么区别 什么时候使用最好 -->
区别：v-if是通过控制dom节点的存在与否来控制元素的显隐；v-show是通过设置DOM元素的display样式，block为显示，none为隐藏；
什么时候使用：如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。

<!-- 3.网站性能优化 -->
   1.尽可能减少HTTP请求
   2.使用雪碧图
   3.css放在文件最上面防止白屏,闪动,js放在最下面
   4.压缩js和css  去除不必要的注释 空格
   5.合理使用缓存
   6.使用CDN(内容分发网络)

<!-- 4.你知道内存泄露吗 -->
    导致网站/软件反应迟缓,崩溃,高延迟
    原因：变量使用没有被回收,造成了内存泄漏,一般由定时器,闭包导致
    vue如何处理  生命周期  beforeDestroy  销毁前做处理
    react如何处理  生命周期  componentWillUnmount 销毁做处理

<!-- 5.link标签和@import的区别 -->
    1.link标签属于html标签,@import是css提供的方式
    2.link除了加载css，还可以做rss(简易联合)，rel属性,@import只能加载css
    3.link引用的css同时被加载，@import引用的css等到页面加载完成后再加载,
    4.link的权重的大于@import
    5.兼容性的差别 @import不兼容IE5以下的,link完全兼容
    
<!-- 10.nginx的好处 -->
   1.高并发连接
   2.内存消耗
   3.成本低
   4.负载均衡
   5.反向代理 

<!-- 11.axios的请求方式 -->
    get：获取数据
    post：提交数据（表单提交+文件上传）
    put：更新数据（所有数据推送到后端）
    patch：更新数据（只将更改的数据推送到后端）
    delete：删除数据

<!-- 12.清除浮动的方式有哪些及优缺点 -->
什么是盒子塌陷？
外部盒子本应该包裹住内部的浮动盒子，结果却没有。

问题出现的原因
父元素只包含浮动元素，那么它的高度就会塌缩为零（前提就是你们没有设置高度（height）属性，或者设置了为auto，就会出现这种情况，如果父元素不包含任何的可见背景，这个问题会很难被注意到。
因为子元素设置了float属性，而float属性会把元素从标准文档流中抽离，直接结果就是外部盒子丢了两个孩子，因为内部没有其它盒子了，所以外部盒子只包裹文本节点内容，却把两个内部盒子扔在外面了。

解决方案

上面分析了问题出现的原因，不难找到第一种解决方案（既然孩子丢了，那就去找呗）——给外部盒子也添加浮动
把外部盒子也从标准文档流中抽离，让它和孩子们见面。
缺点：可读性差，不易于维护（别人很难理解为什么要给父元素也添上float），而且可能需要调整整个页面布局。

在外部盒子内最下方添上带clear属性的空盒子
可以是div也可以是其它块级元素，把 <div style="clear:both;"></div>放在盒内底部，用最下面的空盒子清除浮动，把盒子重新撑起来。
缺点：引入了冗余元素

用overflow:hidden清除浮动
给外部盒子添上这个属性就好了，非常简单。
缺点：有可能造成溢出元素不可见，影响展示效果。

用after伪元素清除浮动
给外部盒子的after伪元素设置clear属性，再隐藏它
这其实是对空盒子方案的改进，一种纯CSS的解决方案，不用引入冗余元素。

.clearfix {*zoom: 1;}
.clearfix:before,.clearfix:after {display: table;line-height: 0;content: "";}
.clearfix:after {clear: both;}
这也是bootstrap框架采用的清除浮动的方法。

题外话

其实还有一种最直接的办法：给每个盒子规定width和height，要多大给多大即可。但这并不算什么解决方案，因为这样的布局不是内容自适应的，但如果页面内容极少发生变动，这也是一个不错的方案，因为它的兼容性是毋庸置疑的。

<!-- 13.对比下px、em、rem有什么不同 -->
px、em、rem都是计量单位，都能表示尺寸，但是有有所不同，而且其各有各的优缺点。

Px表示“绝对尺寸”（并非真正的绝对），实际上就是css中定义的像素（此像素与设备的物理像素有一定的区别，后续详细说明见文末说明1），利用px设置字体大小及元素宽高等比较稳定和精确。Px的缺点是其不能适应浏览器缩放时产生的变化，因此一般不用于响应式网站。

em表示相对尺寸，其相对于当前对象内文本的font-size（如果当前对象内文本的font-size计量单位也是em，则当前对象内文本的font-size的参考对象为父元素文本font-size）。使用em可以较好的相应设备屏幕尺寸的变化，但是在进行元素设置时都需要知道父元素文本的font-size及当前对象内文本的font-size，如有遗漏可能会导致错误。

rem也表示相对尺寸，其参考对象为根元素的font-size，因此只需要确定这一个font-size。
所以推荐使用px 或rem， em 容易出错

<!-- 14.http都有哪些状态码 -->
200 成功
301 重定向
304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
400 (错误请求) 服务器不理解请求的语法。
403 (禁止) 服务器拒绝请求。
404 (未找到) 服务器找不到请求的网页。
500 (服务器内部错误) 服务器遇到错误，无法完成请求。
501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。
503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。
504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。
505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。

<!-- 15.在浏览器中输入url到页面显示出来的过程发生了什么？ -->
这是一道面试中经常能看到的题目，过程其实挺长的，总结过来就是DNS域名解析拿到对应的域名解析，然后就是服务器端和客户端的三次握手建立数据传输通道，四次挥手关闭数据传输通道，客户端根据自己拿到的数据开始渲染页面

<!-- 16.写一个获取数组的最大值、最小值的方法 -->
const arrFirst = [1,'3',4];
const arrSecond = [1,'3','a'];
arrFirst.max();
arrSecond.max();

<!-- 17.你所了解的图片格式及使用场景 -->
GIF

优点：GIF是动态的；支持无损耗压缩和透明度。

缺点：的详细的图片和写实摄影图像会丢失颜色信息；在大多数情况下，无损耗压缩效果不如 JPEG 格式或 PNG 格式；GIF 支持有限的透明度，没有半透明效果或褪色效果。

适用场景：主要用于比较小的动态图标。

▍PNG

优点：PNG格式图片是无损压缩的图片，能在保证最不失真的情况下尽可能压缩图像文件的大小；图片质量高；色彩表现好；支持透明效果；提供锋利的线条和边缘，所以做出的logo等小图标效果会更好；更好地展示文字、颜色相近的图片。

缺点：占内存大,会导致网页加载速度慢；对于需要高保真的较复杂的图像，PNG虽然能无损压缩，但图片文件较大，不适合应用在Web页面上。

适用场景：主要用于小图标或颜色简单对比强烈的小的背景图。

▍JPG

优点：占用内存小，网页加载速度快。

缺点：JPG格式图片是有损压缩的图片，有损压缩会使原始图片数据质量下降，即JPG会在压缩图片时降低品质。

适用场景：由于这种格式图片对色彩表现比较好，所以适用于色彩丰富的图片。主要用于摄影作品或者大的背景图等。不合适文字比较多的图片。

▍SVG

优点：SVG是矢量图形，不受像素影响，在不同平台上都表现良好；可以通过JS控制实现动画效果。

缺点：DOM比正常的图形慢，而且如果其结点多而杂，就更慢；不能与HTML内容集成。

适用场景：主要用于设计模型的展示等。

▍WebP

优点：WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器宽带资源和数据空间。

缺点：相较编码JPEG文件，编码同样质量的WebP文件需要占用更多的计算资源。

适用场景：WebP既支持有损压缩也支持无损压缩。将来可能是JPEG的代替品。

<!-- 18.造成内存泄漏的操作有哪些 -->
GC回收有两种实现方式：标记清除、引用计数
1、没有使用的全局变量；
2、闭包(闭包可以维持函数内部变量);
3、循环引用（引用计数不为0)；
4、setInterval没有被清除；

<!-- 19. 谈一谈你知道的前端性能优化方案有哪些 -->
这个优化的范围挺大，但是总归可以分为服务端优化和客户端优化。

整理如下
客户端优化
减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。
使用CSS雪碧图（CSS Sprites）CSS Sprites一句话：将多个图片合并到一张单独的图片，这样就大大减少了页面中图片的HTTP请求。
减少DOM操作次数，优化javascript性能。
少用全局变量、减少DOM操作、缓存DOM节点查找的结果。减少IO读取操作。
延迟加载 | 延迟渲染
图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。
避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。
服务端优化
尽量减少响应的体积，比如用 gzip 压缩，优化图片字节数，压缩 css 和 js；或加快文件读取速度，优化服务端的缓存策略。
客户端优化 dom、css 和 js 的代码和加载顺序；或进行服务器端渲染，减轻客户端渲染的压力。
优化网络路由，比如增加 CDN 缓存；或增加并发处理能力，比如服务端设置多个域名，客户端使用多个域名同时请求资源，增加并发量。
最后
　　对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。
　　减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。

<!-- 20.公钥加密和私钥加密是什么 -->
私钥加密，也称对称加密，使用一个密钥对内容进行加密和解密，加密算法可以是公开的，但密钥必须保密，常见的私钥加密算法有：DES、AES、RC5

公钥加密，也称非对称加密，使用两个密钥，一个公开密钥用来加密，另一个私有密钥用来解密，基于其特性，可以用作数字签名的功能（如 HTTPS），常见的公钥加密算法有：RSA

<!-- 21.说说你对模块化的理解 -->
模块化解决了代码污染的问题。提高了代码的重复率以及让多人合作编程了可能。

模块化分为

AMD: require.js 为代表，依赖前置，一律先加载再使用。
CMD: sea.js 为代表，依赖就近原则。
UMD: 同时支持 AMD 和 CMD 方法。
ES6 import/export
<!-- 22.说说你对http、https的理解 -->
从是否需要证书方面来看：https协议需要到ca申请证书，一般免费证书很少，需要交费。
从是否安全方面来看：http是超文本传输协议，信息是明文传输（无法加密），https则是具有安全性的ssl加密传输协议。
从写法、端口号来看：http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
从OSI网络模型中来看：http的连接很简单，是无状态的(HTTP工作于应用层)；https协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议、比http协议安全(HTTPS的安全传输机制工作在传输层)
<!-- 23.请描述一下cookies、sessionStorage和localStorage的区别 -->
cookie：存放于浏览器中的数据；常用于会话管理，用户设置，行为跟踪等。在js中可以通过document.cookie来进行设置，获取或删除等操作；不过cookie有许多明显的缺点：
cookie的大小限制在4KB；
cookie会伴随http请求一起被发送，会浪费网络带宽
cookie的正确操作比较困难
webStorage：H5新增的API，数据存放于客户端本地内存中；sessionStorage和localStorage操作一致，而sessionStorage的有效期限为一次session会话（即一个tab页从打开到关闭之间的时间段），localStorage是没有失效时间的（即永久保存，删除需要手动处理）；
<!-- 24.有用过HTML5的webSQL和IndexedDB吗？说说你对它们的理解 -->
webSQL 和 IndexedDB 都是一种客户端的数据存储方案，webSQL已经废弃。IndexedDB 的特点是：存储空间大，使用异步存储数据模式，存放键值对型数据，支持数据库事务等，同时还可以存储多种类型数据，包括 js 对象类型。可以用在前端缓存大量数据。

<!-- 25.src、href、link的区别是什么 -->
href标识超文本引用，用在link和a等元素上，href是引用和页面关联，是在当前元素和引用资源之间建立联系

src表示引用资源，表示替换当前元素，用在img，script，iframe上，src是页面内容不可缺少的一部分。src是source的缩写，是指向外部资源的位置，指向的内部会迁入到文档中当前标签所在的位置；在请求src资源时会将其指向的资源下载并应用到当前文档中，例如js脚本，img图片和frame等元素。

补充：link和@import的区别

两者都是外部引用CSS的方式，但是存在一定的区别：

区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。

区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。

区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。

区别4：ink支持使用Javascript控制DOM去改变样式；而@import不支持。

<!-- 26.HTML5如果不写`<! DOCTYPE html>` ，页面还会正常工作么 -->
页面添加了<! DOCTYPE html>说明该页面采用了W3C标准，如果不加则页面会根据浏览器自身的解析标准来解析，这可能会导致页面在不同的浏览器呈现出不同的效果。
<!-- 27.js动画和css动画有什么区别 -->
js 动画
会进入函数调用栈，走完事件循环才会走渲染，如果过程中还有频繁获取 dom 状态恐怕是药丸。
但相比 css 动画（不考虑 css 变量），js 动画可配置目标值或速率等，搭配 transition 挺不错。
且 js 动画做暂停、反向和复杂的节奏都要更棒。
再比如弧形运动轨迹，对 css 动画而言恐怕就比较难搞了。
css 动画
非常简易的 hover active checked 等动效用 css 来写真是太方便了。
对循环播放的动画，多数情况下也是 css 动画更佳。
css 动画库的复用感觉会相较高很多。
至于所谓的 gpu 加速或 will-change 很难讲哟，真的有效，但却不是很懂。